import { inputData } from "./data";
import { testData } from "./testdata";

const data = inputData.split(" ").map(Number);
const test = testData.split(" ").map(Number);

const part2 = (data: number[]): number => {
  const numberOfDigits = (x: number): number => Math.floor(Math.log10(x)) + 1;

  // Cache stores how many leaves a stone will generate after N steps
  const cache = new Map<string, number>();

  const countLeavesForStone = (
    stone: number,
    remainingSteps: number
  ): number => {
    if (remainingSteps === 0) {
      return 1; // Each stone counts as one leaf at step 0
    }

    const key = `${stone}:${remainingSteps}`;
    if (cache.has(key)) {
      return cache.get(key)!;
    }

    let result: number;
    if (stone === 0) {
      // A zero becomes a 1
      result = countLeavesForStone(1, remainingSteps - 1);
    } else {
      const numDigits = numberOfDigits(stone);
      if (numDigits % 2 === 0) {
        // Even-length numbers split into two
        const halfLength = Math.floor(numDigits / 2);
        // Get divisor for first half (e.g., if halfLength=2, divisor=100)
        const divisor = Math.pow(10, halfLength);
        const firstHalf = Math.floor(stone / divisor);
        const secondHalf = stone % divisor;
        result =
          countLeavesForStone(firstHalf, remainingSteps - 1) +
          countLeavesForStone(secondHalf, remainingSteps - 1);
      } else {
        // Odd-length numbers multiply by 2024
        result = countLeavesForStone(stone * 2024, remainingSteps - 1);
      }
    }

    cache.set(key, result);
    return result;
  };

  // Sum up the leaves generated by each initial stone
  return data.reduce((sum, stone) => sum + countLeavesForStone(stone, 75), 0);
};

console.log(part2(test));
console.log(part2(data));
